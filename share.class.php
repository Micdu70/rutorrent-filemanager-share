<?php

use Flm\Filesystem as Fs;
use Flm\WebController;

class FileManagerShare extends WebController {


	protected $datafile;
	public $data = array();
	private $limits;


	public function __construct($config) {

	    parent::__construct($config);

		global $topDirectory;

		$this->datafile = addslash(getSettingsPath()).'fileshare.dat';
		//$this->check_post($this->postlist);
		$this->load();
		$this->userdir = addslash($topDirectory);
	}

	public function islimited($max, $cur) {
		global $limits;

		return ($limits[$max]) ? (($cur <= $limits[$max]) ? false : true): false;
	}

	public function add($params) {

         $duration = $params->duration;
         $password = $params->pass;
		global $limits;


        $file =  $this->flm->getWorkDir($params->target);

        $pch = explode($this->userdir, $file);


		if((count($pch) < 2) || (($stat = LFS::stat($file)) === FALSE)) {die('Invalid file');}

		if($limits['nolimit'] == 0) {
			if($duration == 0) {die('No limit not allowed');}
		}

		if($this->islimited('duration', $duration)) {die('Invalid duration!');}

		if($this->islimited('links', count($this->data))) {die('Link limit reached');}

		if($password === FALSE) {$password = '';}

		do {$token = $this->random_chars();} while (isset($this->data[$token]));

		if($duration > 0) {
		$this->data[$token] = array(
					 'file' => $file,
					 'size' => $stat['size'],
					 'expire' => time()+(3600*$duration),
					 'password' => $password);
		} else {
		$this->data[$token] = array(
					'file' => $file,
					'size' => $stat['size'],
					'expire' => time()+(3600*876000),
					'password' => $password);
		}
		$this->write();

		return ['error' => 0, 'data' => $this->data];
	}


    private function authenticate() {
        header('WWW-Authenticate: Basic realm="Password"');
        header('HTTP/1.0 401 Unauthorized');
        echo "Not permitted\n";
        exit;
    }

	public function downloadFile()
    {
        if(!isset($_GET['s'])
            || !isset($this->data[$_GET['s']])
            || ($this->data[$_GET['s']]['expire'] < time())
        )
        {
            die('No such file or it expired');
        }

        if($this->data[$_GET['s']]['password'] != "") {


            if (!isset($_SERVER['PHP_AUTH_USER']) || ($_SERVER['PHP_AUTH_PW'] != $this->data[$_GET['s']]['password'])
            )
            {
                $this->authenticate();
            } else {

                $file = $this->data[$_GET['s']]['file'];
                parent::fileDownload($file); // TODO: Change the autogenerated stub

            }}
    }

    public function del($input) {
		$items = json_decode($input);
		if(!$items) { die('Invalid link id');}
		foreach($items as $id) {
			if(isset($this->data[$id])) {unset($this->data[$id]);}
		}
		$this->write();
	}

	public function edit($id, $duration, $password) {
		global $limits;

		if(!isset($this->data[$id])) {die('Invalid link');}

		if($duration !== FALSE) {
			if($limits['nolimit'] == 0) {
				if($duration == 0) {die('No limit not allowed');}
			}
			if($this->islimited('duration', $duration)) {die('Invalid duration!');}
			if($duration > 0) {
				$this->data[$id]['expire'] = time()+(3600*$duration);
			} else {
				$this->data[$id]['expire'] = time()+(3600*876000);
			}
		}

		if($password === FALSE) {
			$this->data[$id]['password'] = '';
		} else {
			$this->data[$id]['password'] = $password;
		}
		$this->write();
	}

	public function show() {
		$out = array( 'uh' => base64_encode(getUser()),
				'list' => array());

		$out['list'] = $this->data;

		cachedEcho(json_encode($out));
	}


	public function random_chars($length = "32") {

		$rnd = '';

		for ($i=0; $i<$length; $i++) {
    			$lists[1] = rand(48,57);
    			$lists[2] = rand(65,90);
    			$lists[3] = rand(97,122);

			$randchar = $lists[rand(1,3)];

    			$rnd .= chr($randchar);
		}

 		return $rnd;
	}


	protected function load() {
		if(!is_file($this->datafile) && !$this->write()) {die('Failed to write file');}

		if(($rf = file_get_contents($this->datafile)) === FALSE) {die('Failed to load data');}
		$this->data = unserialize($rf);
	}


	private function write() {

		return (file_put_contents($this->datafile, serialize($this->data)) !== FALSE);

	}

  	public function __destruct() {
   	}

}
